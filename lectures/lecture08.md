# Языки программирования и пользовательские типы данных

##  Функции

Классически в постгресе были только функции, процедуры появились только с 11 постгреса. Не всегда мы можем на классическом голом sql  реализовать сложный функционал (сходить на диск, в другую таблицу, сделать какие то кастомные вещи). Поэтому и нужны процедуры и функции.

Зачем нужны:
- считать данные из базы
- изменить данные
- удалить
- может получить доступ к файловой системе
- может получить доступ к сети, в т.ч. в интернету
- разграничить доступ и возможность изменения/удаления данных разработчиками софта для этой БД
 
[Функции, написанные на PL/pgSQL](https://www.postgresql.org/docs/16/sql-createfunction.html), определяются на сервере командами `CREATE FUNCTION`. Такая команда обычно выглядит, например, так:
```sql
CREATE FUNCTION somefunc(integer, text) RETURNS integer AS 'тело функции'  -- несмотря на то что описание функции идет в кавычках - на самом деле может быть любой набор символов, классически идут $$ ... $$ так как апострофы слишком часто встречаются!
LANGUAGE plpgsql;
```
Один из плюсов использования функций-процедур - это когда у нас сложная логика, нам необязательно отправлять запрос, что то делать и отправлять новый запрос. Мы эту логику можем переложить на сторону бэкэнда и в десятки-сотни раз ускориться.

Если рассматривать `CREATE FUNCTION`, то тело функции представляет собой просто текстовую строку. Часто для написания тела функции удобнее заключать эту строку в доллары, а не в обычные апострофы.
https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING
Если не применять заключение в доллары, все апострофы или обратные косые черты в теле функции придётся экранировать, дублируя их.
 
Синтаксис функции:
```sql
CREATE [ OR REPLACE ] FUNCTION
имя ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ { DEFAULT | = }
выражение_по_умолчанию ] [, ...] ] ) [ RETURNS тип_результата
| RETURNS TABLE ( имя_столбца тип_столбца [, ...] ) ] { LANGUAGE имя_языка
... } ... 
```
классически возвращается какой то тип данных (можно возвращать как скалярный результат, так и таблицы!). Также обязательно указать язык!

Ссылки
- https://www.postgresql.org/docs/16/sql-createfunction.html - список языков
- https://www.postgresql.org/docs/15/xplang.html
- Питон! https://www.postgresql.org/docs/15/plpython.html 
- https://habr.com/ru/company/postgrespro/blog/502254/

REPLACE работает только когда совпадают типы и количество аргументов!

### Параметры функции

Классически у нас функция волатильная (VOLATILE) - то есть она вызывается каждый раз, когда встречается в коде. То есть мы вызываем ее для каждой строчки - для каждой строчки она будет вызвана. Противоположность - STABLE, мы говорим Постгресу что он может закэшировать значение этой функции и в рамках одной транзакции можно ее не вызывать для одинаковых значений. IMMUTABLE - повышение уровня кэшируемых значений. То есть если у нас какие то математические операции - зачем нам каждый раз высчитывать если мы можем закэшировать значение. Но если мы ходим в какие то таблицы и выбираем какие то значения и эти таблицы могут меняться - то нам нужен уровень VOLATILE.
- IMMUTABLE - показывает, что функция не может модифицировать базу данных и всегда возвращает один и тот же результат при определённых значениях аргументов. Она не обращается к базе данных и не использует информацию, не переданную ей явно в списке аргументов. Если функция имеет такую характеристику, любой её вызов с аргументами-константами можно немедленно заменить значением функции.
  Встречается довольно редко - мы берем на себя ответственность что мы кэшируем эти значения. Это может привести к тому что мы будем получать последующие неправильные значения - например, сделали функцию подсчета строк иммутабельной и затем начинаем строки добывлять.  
- STABLE показывает, что функция не может модифицировать базу данных и в рамках одного сканирования таблицы она всегда возвращает один и тот же результат для определённых значений аргументов, но этот результат может быть разным в разных операторах SQL. Хороший выбор для функций, результаты которых зависят от содержимого базы данных и настраиваемых параметров (например, текущего часового пояса). Но этот вариант не подходит для триггеров AFTER, желающих прочитать строки, изменённые текущей командой.
- VOLATILE показывает, что результат функции может меняться даже в рамках одного сканирования таблицы, так что её вызовы нельзя оптимизировать. Изменчивы в этом смысле относительно немногие функции баз данных, например: random(), currval() и timeofday(). Важно, что любая функция с побочными эффектами должна быть классифицирована как изменчивая, даже если её результат вполне предсказуем, чтобы её вызовы не были соптимизированы; пример такой функции: setval().

В документации сказано что кэшируется в рамках транзакции, но по факту кэшируется в рамках сессии. Почему иногда сбрасывают - если в MSSQL мы можем посмотреть, что у нас закэшировано, то в постгресе мы этого сделать не можем. Поэтому изменять этот параметр нужно осознанно. Если хотим кэшироваться - то нужно поднимать уровень волатильности! По умолчанию функция всегда будет выполняться

Параметры - обработка налл. С налл не рекомендуется работать! Лучше делать нот налл! Большинство операций с налл возвращают налл, по хорошему переменные с налл нужно обрабатывать
- CALLED ON NULL INPUT (default) показывает, что функция будет вызвана как обычно, если среди её аргументов оказываются значения NULL. В этом случае ответственность за проверку значений NULL и соответствующую их обработку ложится на разработчика функции
- RETURNS NULL ON NULL INPUT показывает, что функция всегда возвращает NULL, получив NULL в одном из аргументов. Такая функция не будет вызываться с аргументами NULL, вместо этого автоматически будет полагаться результат NULL
- STRICT аналогичен указанию RETURNS NULL ON NULL INPUT (можем запретить передавать налл - получили налл == получили ошибку)

Еще одна важная штука - параметры связанные с безопасностью вызывающего/определяющего: есть определенная модель разграничения доступа. По умолчанию функция выполняется с правами вызывающего. Мы можем закрыть доступ напрямую к таблицам, создать определенный набор функций/процедур, у которых определить DEFINER нужного уровня и она вызывется с нужными нам правами. Так мы можем полностью ограничить, какие пользователь может вносить изменения, структуру базы, добавляет еще один слой абстракции. Добавляет небольшой оверхед, но так мы можем спокойно менять структуру, для приложений все останется прозрачным и их переписывать не понадобится.
- SECURITY INVOKER (безопасность вызывающего) показывает, что функция будет выполняться с правами пользователя, вызвавшего её.
- SECURITY DEFINER (безопасность определившего) определяет, что функция выполняется с правами пользователя, владеющего ей. Интересная особенность при вызове суперюзером функции SECURITY DEFINER c ограниченными правами - доступ мы не получим

Есть интересный подход когда мы закрываем юзерам доступ ко всему кроме хранимых процедур. Пользователю выдаем права на них, а уже процедурам выдаем нужные права для таблиц. Так мы делаем новый уровень абстракции. Огромный плюс - уровень абстракции, огромный минус - накладные расходы

Параметр паралеллизации функции - классически выбирается параллельный вариант выполнения, но мы можем указать что внутри в целом если есть возможность чтобы постгрес распараллил запросы (parallel seq scan , parallel index scan) (лектор на практике не видел применения)
- PARALLEL UNSAFE (default) означает, что эту функцию нельзя выполнять в параллельном режиме и присутствие такой функции в операторе SQL приводит к выбору последовательного плана выполнения.
- PARALLEL RESTRICTED означает, что функцию можно выполнять в параллельном режиме, но только в ведущем процессе группы. PARALLEL SAFE показывает, что функция безопасна для выполнения в параллельном режиме без ограничений.
 
Важно! не путать использование BEGIN/END для группировки операторов в PL/pgSQL с одноимёнными SQL командами для управления транзакциями. BEGIN/END в PL/pgSQL служат только для группировки предложений; они не начинают и не заканчивают транзакции.
 
## Язык PL/PgSQL

Несмотря на то, что мы можем писать функции на чистом SQL, в Постгресе был придуман PL/pgSQL.
Основные цели загружаемого процедурного языка:
- может выполнять сложные вычисления,
- используется для создания функций и триггеров,
- добавляет управляющие структуры к языку SQL,
- наследует все пользовательские типы, функции и операторы,
- прост в использовании.
Функции PL/pgSQL могут использоваться везде, где допустимы встроенные функции. Например, можно создать функции со сложными вычислениями и условной логикой, а затем использовать их при определении операторов или в индексных выражениях. В версии PostgreSQL 9.0 и выше, PL/pgSQL устанавливается по умолчанию.

Почему еще может быть важно использовать хранимые функции: допустим, наш бэкэнд собирается что то обработвать - сделал запрос, получил результат, данные обработал, сделал на их основе следующий результат. Всю эту логику можно убрать на хранимки. Соответственно, убираем обращение между клиентом и сервером, ускоряясь значительно (тк никакие промежуточные результаты не передаются, код выполняется на сервере). Главное - не перегибать палку (не переносить вообще все на хранимки). Еще проблема - миграции.

PL/pgSQL позволяет сгруппировать блок вычислений и последовательность запросов внутри сервера базы данных, таким образом, мы получаем силу процедурного языка и простоту использования SQL при значительной экономии накладных расходов на клиент- серверное взаимодействие.
Важные особенности:
- Исключаются дополнительные обращения между клиентом и сервером
- Промежуточные ненужные результаты не передаются между сервером и клиентом
- Есть возможность избежать многочисленных разборов одного запроса

В результате это приводит к значительному увеличению производительности по сравнению с приложением, которое не использует хранимых функций. Кроме того, PL/pgSQL позволяет использовать все типы данных, операторы и функции SQL.
 
## Основы языка

Создали мы функцию. Функция обчно вызывается с какими то параметрами и нужно их обработать. Так вот, у нас есть разные типы этих параметров. Если мы ничего не указываем в режим параметров - то это будет по умолчанию входной параметр. Далее у нас есть 2 варианта - либо указать тип результата (RETURN), либо сделать выходную переменную (OUT) (то есть они не совместимы!)

`FUNCTION ([режим] параметр 1, [режим] параметр 2 ...) RETURN тип_результата`

Режимы:
- IN (входной) (default)
- OUT (выходной)
- INOUT (входной и выходной) - у нас есть переменная x, изменяем ее и возвращаем
- VARIADIC (переменный) (когда мы не знаем, сколько будет параметров на входе) - За единственным аргументом VARIADIC могут следовать только аргументы OUT. Кроме того, аргументы OUT и INOUT нельзя использовать с предложением RETURNS TABLE!
 
Варианты возвращаемых данных:
- Тип возвращаемых данных. Это может быть базовый, составной, либо ссылка на тип столбца таблицы. В зависимости от языка реализации здесь также могут допускаться составные типы. Если функция не должна возвращать значение, в качестве типа результата указывается void
- Указание SETOF показывает, что функция возвращает множество, а не единственный элемент.
- Можно вернуть таблицу

Разница между множеством и таблицей довольно призрачная. Считается что в множестве порядок не гарантирован, а в таблицу в каком порядке мы данные записали - в таком порядке она их нам и вернет.

Для того, чтобы вернуть какие то значения, какой нибудь тип данных или множество, есть RETURN выражение. RETURN с последующим выражением прекращает выполнение функции и возвращает значение выражения в вызывающую программу. Эта форма используется для функций PL/pgSQL, которые не возвращают набор строк. 
- В функции, возвращающей скалярный тип, результирующее выражение автоматически приводится к типу возвращаемого значения. Однако, чтобы вернуть составной тип (строку), возвращаемое выражение должно в точности содержать требуемый набор столбцов. При этом может потребоваться явное приведение типов.
- Для функции с выходными параметрами просто используйте RETURN без выражения. Будут возвращены текущие значения выходных параметров.
- Для функции, возвращающей void, RETURN можно использовать в любом месте, но без выражения после RETURN.
 
Как вернуть простые типы данных:

Возвращаемое значение функции не может остаться не определённым. Если достигнут конец блока верхнего уровня, а оператор RETURN так и не встретился, происходит ошибка времени исполнения. Это не касается функций с выходными параметрами и функций, возвращающих void. Для них оператор RETURN выполняется автоматически по окончании блока верхнего уровня. Несколько примеров:
```sql
-- Функции, возвращающие скалярный тип данных
RETURN 1 + 2; RETURN scalar_var;
-- Функции, возвращающие составной тип данных
RETURN composite_type;  -- специальная запись для составного типа
RETURN (1, 2, 'three'::text); -- требуется приведение типов
```

Для функций на PL/pgSQL, возвращающих SETOF некий_тип, нужно действовать несколько по-иному. Отдельные элементы возвращаемого значения формируются командами RETURN NEXT (по одной строчке наполняем таблицу) или RETURN QUERY (запрос донаполняем - сделяем select, в конец добавим union all), а финальная команда RETURN без аргументов завершает выполнение функции. 

RETURN NEXT используется как со скалярными, так и с составными типами данных. Для составного типа результат функции возвращается в виде таблицы. RETURN QUERY добавляет результат выполнения запроса к результату функции. RETURN NEXT и RETURN QUERY можно свободно смешивать в теле функции, в этом случае их результаты будут объединены.
- RETURN NEXT выражение;
- RETURN QUERY запрос;
- RETURN QUERY EXECUTE строка-команды [USING выражение [, ...]]; - это динамический sql, где мы можем не просто написать запрос, а подставить переменную! Это позволяет нам на грязных данныз, которые мы получили из интернета, защититься от sql инъекций.

### Основные операторы:

Присвоение значения переменной PL/pgSQL записывается в виде:
`переменная { := | = } выражение; `
Примеры:
`tax := total * 0.04; user_id = 40;`

[Дока](https://www.postgresql.org/docs/current/plpgsql-statements.html)
 
Переменные всегда должны быть объявлены заранее! Значение по умолчанию вычисляется и присваивается переменной каждый раз при входе в блок. О них чуть дальше. Так, например, если переменная типа timestamp имеет функцию now() в качестве значения по умолчанию, это приведёт к тому, что переменная всегда будет содержать время текущего вызова функции, а не время, когда функция была предварительно скомпилирована.
Примеры присвоения значений:
```sql
quantity timestamp DEFAULT now();  -- имя переменной, тип переменной, значение по умолчанию
url varchar := 'Ivan Ivanov';
user_id CONSTANT integer := 100;  -- константы используются довольно редко, в производительности разницы нет
```

Переданные в функцию параметры именуются идентификаторами $1, $2 и т.д. Создать псевдоним можно двумя способами. Предпочтительный способ это дать имя параметру в команде `CREATE FUNCTION`, а не полагаться на нумерацию параметров, например:
```sql
CREATE FUNCTION sales(total real) RETURNS real AS $$ BEGIN
RETURN total * 2; END;
$$ LANGUAGE plpgsql;
```

Также нам нужно оперделиться, как вызывать передаваемое значение параметра. Самый правильный пример - это дать имя и указать тип (`sales(total real)`), но мы можем и просто указать тип, тогда к нему можно будет обратиться двумя видами: через алиас (`имя ALIAS FOR $n;`) и через $. Предыдущий пример для этого стиля выглядит так:
```sql
CREATE FUNCTION sales_tax(real) RETURNS real AS $$ 
DECLARE
    subtotal ALIAS FOR $1; 
BEGIN
    RETURN subtotal * 0.06; 
END;
$$ LANGUAGE plpgsql;
```
Минус здесь в том что состав переменных может меняться.

Обратите внимание, что эти два примера не полностью эквивалентны. В первом случае на total можно ссылаться как sales.total, а во втором случае такая ссылка невозможна. Если бы к внутреннему блоку была добавлена метка, то total можно было бы дополнить этой меткой. Но про блоки мы поговорим с вами дальше.

Когда функция на PL/pgSQL объявляется с выходными параметрами, им по аналогии выдаются цифровые идентификаторы $n и для них можно создавать псевдонимы точно таким же способом, как и для обычных входных параметров. Выходной параметр это фактически переменная, стартующая с NULL и которой присваивается значение во время выполнения функции. Возвращается последнее присвоенное значение. Например, функция sales может быть переписана так:
```sql
CREATE FUNCTION sales(total real, OUT tax real) AS $$ -- in обычно никто не пишет, но пишут OUT еслит есть выходная переменная. При этом не забываем, что если есть OUT - мы не пишем ретурн!
BEGIN
    tax := total * 0.04; 
END;
$$ LANGUAGE plpgsql;
```
То есть допускается не писать ретерн - в этом случае просто дойдет до END и вернет tax (то что в OUT).

PostgreSQL допускает перегрузку функций, то есть, позволяет использовать одно имя для нескольких различных функций, если у них различаются типы входных аргументов. Независимо от того, используете вы эту возможность или нет, [она требует предосторожности](https://www.postgresql.org/docs/current/typeconv-func.html) при вызове функций в базах данных, где одни пользователи не доверяют другим. Две функции считаются совпадающими, если они имеют одинаковые имена и типы входных аргументов, параметры OUT игнорируются. Таким образом, например, эти объявления вызовут конфликт:
```sql
CREATE FUNCTION func(int) ...
CREATE FUNCTION func(int, out text) ...
```
То есть мы можем создать 2 функции с совпадающим именем. Далее, когда она будет вызываться, постгрес просто посмотрит набор входных парамтеров и их количество, найдет соответсвующую функцию и ее вызовет. Здесь есть ряд проблем с конфликтами.

Функции, имеющие разные типы аргументов, не будут считаться конфликтующими в момент создания, но предоставленные для них значения по умолчанию могут вызвать конфликт в момент использования. Например, рассмотрите следующие определения:
```sql
CREATE FUNCTION func(int) ...
CREATE FUNCTION func(int, int default 2) ...  -- дефолтное значение все ломает, тк мы можем вызвать функцию с одним значением
```
Вызов foo(100) завершится ошибкой из-за неоднозначности в выборе вызываемой функции

Еще у нас есть возможность вызвать запрос (если запрос не возвращает результат - в данном случае void) - это делает оператор PERFORM. В функции на PL/pgSQL можно выполнить любую команду SQL, не возвращающую строк, просто написав эту команду (например, INSERT без предложения RETURNING). Иногда бывает полезно вычислить значение выражения или запроса SELECT, но отказаться от результата, например, при вызове функции, у которой есть побочные эффекты, но нет полезного результата. Для этого в PL/pgSQL, используется оператор PERFORM: 
`PERFORM запрос;`
 
Внутри нашего кода мы можем выбирать опеределенные наборы полей из таблиц в переменную. То есть мы можем объявить переменную и туда набирать. Результат SQL команды, возвращающей одну строку (возможно из нескольких столбцов), может быть присвоен переменной типа record, переменной строкового типа или списку скалярных переменных (рекорд - это анонимная переменная, любого количества/набора элементов). Для этого нужно к основной команде SQL добавить предложение INTO. Так, например:
```sql
SELECT список_полей INTO [STRICT] цель FROM ...;
DELETE ... RETURNING список_полей INTO [STRICT] цель;
INSERT ... RETURNING список_полей INTO [STRICT] цель;
UPDATE ... RETURNING список_полей INTO [STRICT] цель;
```
Предложение INTO может появиться практически в любом месте SQL-команды. Обычно его записывают непосредственно перед или сразу после списка в SELECT или в конце команды для команд других типов. НО! получить мы можем только 1 значение (больше одного - любом которое попалось)(стрикт чуть меняет логику)

Если указание STRICT отсутствует в предложении INTO, то цели присваивается первая строка, возвращённая запросом; или NULL, если запрос не вернул строк. Все остальные строки результата после первой отбрасываются. Можно проверить специальную переменную FOUND, чтобы определить, была ли возвращена запись:
```sql
SELECT * INTO myrec FROM emp WHERE empname = myname; 
IF NOT FOUND THEN
    RAISE EXCEPTION 'Сотрудник % не найден', myname; 
END IF;
```
[дока](https://www.postgresql.org/docs/current/plpgsql-statements.html#PLPGSQL-STATEMENT S-DIAGNOSTICS)
 
Если добавлено указание STRICT, то запрос должен вернуть ровно одну строку или произойдёт ошибка во время выполнения: либо NO_DATA_FOUND (нет строк), либо TOO_MANY_ROWS (слишком много строк). Можно использовать секцию исключений в блоке для обработки ошибок, например:
```sql
BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE emp_name = name; 
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'Сотрудник % не найден', name;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'Сотрудник % уже существует', name; 
END;
``` 
Исключения можем обрабатывать - перехватывать исключения (правда, это дорого, тк создается стэк вызовов и так далее)

В тексте функции мы не можем коммитить или роллбэчить транзакции! В процедуре можем

## Типы данных 35 00

Если мы посмотрим [документацию](https://www.postgresql.org/docs/current/datatype.html) ПГ, то увидим множество типов данных. Но по факту все значительно проще - основные 5 закрывают 99 процентов случаем. [Хабр](https://habr.com/ru/company/ozontech/blog/645173/)
 
По факту какие типы используются в ПГ:
- для текста - text (в основном используется он) (варчар и текст - в постгресе никакой разницы (в мускуле есть), так что лучше использовать текст)
- для целых чисел int (синтаксический сахар над integer)
- для вещественных real (в промышленности не применяется, проблемы с округлением на малых чисел)
- для денег decimal (синоним numeric), не money!!! из-за проблем с округлением в сша (к ближайшему четному, а не как у людей)
- дата и время - date & timestamp. Если нужен часовой пояс то Z в конце

В целом и все. (А нет, JSON, посмотрим на 10 занятии)

Также у нас есть возможно создавать свои типы данных, эдакое ООП
```sql
CREATE TYPE currency AS (
    amount numeric,
    code text
);
CREATE TABLE transactions
(
    account_id integer,
    debit currency,
    credit currency,
    date_entered date DEFAULT current_date
);
```
 
## Блоки. Понятие и варианты реализации

PL/pgSQL это блочно-структурированный язык. Текст тела функции должен быть блоком. Структура блока:
```sql
[ <<метка>> ] 
[ DECLARE
    объявления ] 
BEGIN
    операторы  -- Вместо любого оператора в блоке может быть такой же блок
END [ метка ];
```
Каждое объявление и каждый оператор в блоке должны завершаться символом ";"(точка с запятой). Блок, вложенный в другой блок, должен иметь точку с запятой после END, как показано выше. Однако финальный END, завершающий тело функции, не требует точки с запятой.

Метка позволяет нам выйти на любой уровень вложенности. Или обратиться в переменной с о динаковым именем на любой другой уровень, который у нас есть.
 
Метка требуется только тогда, когда нужно идентифицировать блок в операторе EXIT, или дополнить имена переменных, объявленных в этом блоке. Если метка указана после END, то она должна совпадать с меткой в начале блока. 

Ключевые слова не чувствительны к регистру символов. Как и в обычных SQL-командах, идентификаторы неявно преобразуются к нижнему регистру, если они не взяты в двойные кавычки. Комментарии в PL/pgSQL коде работают так же, как и в обычном SQL. Двойное тире (--) начинает комментарий, который завершается в конце строки. Блочный комментарий начинается с /* и завершается */. Блочные комментарии могут быть вложенными.

Вложенность - Любой оператор в выполняемой секции блока может быть вложенным блоком, обычно нужно для логической группировки. Вложенные блоки используются для логической группировки нескольких операторов или локализации области действия переменных для группы операторов. Во время выполнения вложенного блока переменные, объявленные в нём, скрывают переменные внешних блоков с такими же именами. Чтобы получить доступ к внешним переменным, нужно дополнить их имена меткой блока.

Пример из документации
```sql
CREATE FUNCTION somefunc() RETURNS integer AS $$ 
<< out_block >>  -- внешний блок
DECLARE
    quantity integer := 300; 
BEGIN
    RAISE NOTICE 'Сейчас quantity = %', quantity; -- Выводится 300 quantity := 500;
    --
    -- Вложенный блок
    -- DECLARE
    quantity integer := 800; 
    BEGIN
        RAISE NOTICE 'Сейчас quantity = %', quantity; -- Выводится 800
        RAISE NOTICE 'Во внешнем блоке quantity = %', out_block.quantity; -- Выводится 500 
    END;
    -- как только выходим из блока - все переменные, объявленные в нем, уничтожаются

    RAISE NOTICE 'Сейчас quantity = %', quantity; -- Выводится 500

    RETURN quantity; 
END;
$$ LANGUAGE plpgsql;
```
RAISE NOTICE выведет нам в окно вывода.

Вместо любого оператора может быть свой блок. Имена блока должны отличаться! Если у блока нет имени - то мы не можем к нему обратиться.

## Процедуры (46 00)

Появились в PostgreSQL 11
```sql
CREATE [ OR REPLACE ] PROCEDURE
имя ( [ [ режим_аргумента ] [ имя_аргумента ] тип_аргумента [ { DEFAULT | = }
выражение_по_умолчанию ] [, ...] ] ) 
{ LANGUAGE имя_языка
... }...
```
Отличие состоит в том, что процедура не возвращает значение, и поэтому для неё не определяется возвращаемый тип (это классическое определение и оно не совсем верно - мы не можем указать ретерн, но можем сделать режим аргумента out - указать out переменную ). Функция может вызываться в составе запроса или команды DML, процедура [вызывается явно](https://www.postgresql.org/docs/current/sql-createprocedure.html), оператором [CALL](https://postgrespro.ru/docs/postgresql/15/sql-call)

еще отличие - функцию мы можем вызвать прям внутри селекта, процедура вызывается специальным оператором call! еще (вроде как) процедуры кэшируются
 
В чем еще отличие - иногда нам нужно выполнить какой то код и какие то временные переменные
Анонимный блок DO в PL/pgSQL или одномоментная процедура:
```sql
DO $$ DECLARE
    r record; 
BEGIN
    SELECT id, code INTO r FROM t WHERE id = 1;
    RAISE NOTICE '%', r; 
END;
$$;
```
здесь нет create procedure, мы просто говорим "выполни ...". Одноразовая процедурка, когда нужно написать сложный код, с переменными.

Обычно в процедуру запихиваем рутинную работу. Вызываешь ночью, она анализирует, какие есть МВ, их пересчитывает, собирает какой то отчет и тд. А функции обычно вызываем в коде sql.
 
Функция, другая процедура или анонимный блок DO в PL/pgSQL может вызвать процедуру, используя оператор CALL (из процедуры можем вызвать функцию и наборот - вложенность не ограничена). Каждому выходному параметру INOUT для процедуры должна соответствовать переменная в операторе CALL, и этой переменной по завершении процедуры будет присвоено возвращаемое процедурой значение.
```sql
DO $$ DECLARE
r record; BEGIN
CALL test(r);
RAISE NOTICE '%', r; END;
$$;
```
 
Процедура не возвращает никакого значения, поэтому она может завершаться без оператора RETURN. Если вы хотите досрочно завершить выполнение кода оператором RETURN, напишите просто RETURN без возвращаемого выражения. Если у процедуры есть выходные параметры, конечные значения соответствующих им переменных будут выданы вызывающему коду.

В процедуре мы можем управлять транзакциями!
 
Внутри PL/pgSQL можно использовать без изменений практически любые команды SQL, не возвращающие результат: `INSERT, UPDATE, DELETE, CREATE, DROP...` . Команды INSERT, UPDATE, DELETE могут возвращать результат с помощью фразы RETURNING. Их можно использовать в PL/pgSQL точно так же, как SELECT, добавив фразу INTO.

Условные операторы Операторы IF и CASE позволяют выполнять команды в зависимости от определённых условий. PL/pgSQL поддерживает три формы IF:
- `IF ... THEN ... END IF`
- `IF ... THEN ... ELSE ... END IF`
- `IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF`

и две формы CASE
- `CASE ... WHEN ... THEN ... ELSE ... END CASE`
- `CASE WHEN ... THEN ... ELSE ... END CASE`
 
[Основные управляющие конструкции](https://www.postgresql.org/docs/current/plpgsql-control-structures.html) - Наиболее полезная и важная часть PL/pgSQL.
С их помощью можно очень гибко и эффективно манипулировать данными в PostgreSQL.
Сегодня мы НЕ рассмотрим (оставим на 2 запуск): 
- Циклы
- Исключения
- Динамический SQL
- Триггеры, в т.ч. DDL
 
## Практика

53-60 минута - поднимаем вм и ставим постгрес!!!! 

```sql
-- вывод notice в DBeaver
shift+ctrl+o  
/*
  тоже комментарий
*/

ПГадмин - тугой, не рекомендуют пользоваться

-- простые примеры 
-- язык SQL
drop function if exists add;
CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'SELECT $1 + $2;'
LANGUAGE SQL
IMMUTABLE  -- мы делаем сложение первого и второго аргумента. Сложение - это у нас иммутабельная операция (на сложение одних и тех же аргументов мы получим всегда одинаковый результат!)
RETURNS NULL ON NULL INPUT;

SELECT add(3,4);
SELECT * from add(3,4);  -- в данном случае нам вернется табличка

SELECT add(null,20);


-- такая же функция, но например она если не получает втоорой аргумент, то подставляет 42
-- если дефолтное значение и вызов с NULL INPUT
drop function add2;
CREATE or replace FUNCTION add2(integer, integer default 42) RETURNS integer
    AS 'SELECT $1 + $2;'
LANGUAGE SQL
IMMUTABLE
RETURNS NULL ON NULL INPUT;

SELECT add2(20, null);  
SELECT add2(20);

-- Функция увеличения целого числа на 1, использующая именованный аргумент, на языке PL/pgSQL:
-- обратим внимание на OR REPLACE
CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
BEGIN
    RETURN i + 1;
END;
$$ LANGUAGE plpgsql;
-- с plpgsql мы уже пишем BEGIN, END и все остальное что хотим написать

SELECT increment(3);  -- на предыдущие вызовы не влияет! то есть при перевызовах все равно получим 4


-- Функция, возвращающая запись с несколькими выходными параметрами:
-- входная переменная и 2 выходные переменные
CREATE FUNCTION dup(in int, out f1 int, out f2 text) AS $$ 
    SELECT $1, CAST($1 AS text) || ' is text' 
$$
LANGUAGE SQL;
/*
что мы делаем:
- язык SQL
- выбиарем первую переменную, вторая будет конкатенироваться с текстом
*/

SELECT * FROM dup(42);  -- вернет таблицу
/*
pg_db=# SELECT * FROM dup(42);
 f1 |     f2     
----+------------
 42 | 42 is text
(1 row)
*/
SELECT dup(42);  -- вернет 1 значение!
/*
pg_db=# SELECT dup(42);
        dup        
-------------------
 (42,"42 is text")
(1 row)
*/
-- то есть это разный вид обращения к функции!

-- примеры объявления параметров - через разные обращения к переменным 1, 2
CREATE OR REPLACE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- вычисления, использующие v_string и index
    	return v_string + index;  -- автоприведение типов иногда очень плохо работает! Лучше прописать вручную! 
--	return v_string::int + index;
END;
$$ LANGUAGE plpgsql;

select instr('1',2);
/*
ERROR:  operator does not exist: character varying + integer
LINE 1: v_string + index
                 ^
HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
QUERY:  v_string + index
CONTEXT:  PL/pgSQL function instr(character varying,integer) line 7 at RETURN
*/
-- можем преобразовать сами
CREATE OR REPLACE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- вычисления, использующие v_string и index
    	return v_string::int + index;
--	return v_string::int + index;
END;
$$ LANGUAGE plpgsql;

select instr('1',2);
/*
 instr 
-------
     3
(1 row)
*/
-- на автоприведение лучше не полагаться - оно работает не всегда!


-- c out, без return
CREATE FUNCTION sales_tax2(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;

select sales_tax2(200);


-- как вернуть значение для каждой строчки из таблицы
create table sales(summa numeric);
insert into sales values ('202.10'), ('2024.24');
-- мы можем каждое значение передать в функцию
SELECT * FROM sales;
SELECT sales_tax2(cast(sales.summa as real)) FROM sales;
/*
 sales_tax2 
------------
     12.126
   121.4544
(2 rows)
*/

-- несколько выходных параметров
drop function if exists sum_n_product;
CREATE FUNCTION sum_n_product(x int, IN y int, OUT sum int, OUT prod int) AS $$
-- IN писать не обязательно, в проде никто никогда не пишет!
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;

SELECT sum_n_product(200, 400);
/*
 sum_n_product 
---------------
 (600,80000)
(1 row)
*/
SELECT * from sum_n_product(200, 400);
/*
 sum | prod  
-----+-------
 600 | 80000
(1 row)
*/
-- можем вернуть и только 1 поле, потому что у нее есть имя!
SELECT prod from sum_n_product(200, 400);
/*
 prod  
-------
 80000
(1 row)
*/

-- пример переменной inout (входная-выходная переменная)
drop function if exists return_inout;
CREATE or replace function return_inout(inout result1 int, out result2 int)
as $$
begin
    result2 := result1;  
    result1 := 1;
return;
end
$$ language plpgsql; 

SELECT return_inout(6);
select * from return_inout(6);
/*
 result1 | result2 
---------+---------
       1 |       6
(1 row)
*/


-- вернем таблицу
drop TABLE if exists sales;
CREATE TABLE sales (itemno int, price int, quantity int);
INSERT INTO sales VALUES (1,10,100),(2,20,200);


drop function if exists extended_sales;
-- функция, которая вернет нам табличку из 2 полей - количество и сумма продажи
CREATE or replace FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total int) AS $$
BEGIN
    -- верни запрос - и пишем сам запрос. Табличка это от 0 и больше значений, ограничений никаких нет
    RETURN QUERY SELECT s.quantity as a, s.quantity * s.price as b FROM sales s
                 WHERE s.itemno = p_itemno;
/*
-- jмжем дообогатить табличку - вернуть больше значений
    RETURN QUERY SELECT s.quantity as a, s.quantity * s.price as b FROM sales s
                 WHERE s.itemno = p_itemno;
*/
END;
$$ LANGUAGE plpgsql;

SELECT * FROM sales;
/*
 itemno | price | quantity 
--------+-------+----------
      1 |    10 |      100
      2 |    20 |      200
(2 rows)
*/
SELECT extended_sales(1);
SELECT * from extended_sales(1);
/*
 quantity | total 
----------+-------
      100 |  1000
(1 row)
*/

SELECT extended_sales(itemno) from sales;
/*
 extended_sales 
----------------
 (100,1000)
 (200,4000)
(2 rows)
*/



-- использование составного типа
CREATE TYPE currency AS (
    amount numeric,
    code   text
);
drop table if exists transactions;
CREATE TABLE transactions(
    account_id   integer,
    debit        currency,
    credit       currency,
    date_entered date DEFAULT current_date
);


-- 3 варианта вставки!
-- Значения составного типа можно формировать либо в виде строки, 
-- внутри которой в скобках перечислены значения
INSERT INTO transactions VALUES(1, NULL, '(7000.00,"RUR")');

-- Либо с помощью табличного конструктора ROW:
INSERT INTO transactions VALUES(2, ROW(350.00,'RUR'), NULL);

-- Если составной тип содержит более одного поля, то слово ROW можно опустить:
INSERT INTO transactions VALUES(3, (20.00,'RUR'), NULL);

SELECT * FROM transactions;
/*
 account_id |    debit     |    credit     | date_entered 
------------+--------------+---------------+--------------
          1 |              | (7000.00,RUR) | 2024-11-21
          2 | (350.00,RUR) |               | 2024-11-21
          3 | (20.00,RUR)  |               | 2024-11-21
(3 rows)
*/


-- Функция для работы с составным типом:
CREATE TYPE dup_result AS (f1 int, f2 text);
-- будет возвращать составной тип! в возвращении 2 переменных, он автоматом их преобразует
CREATE or replace FUNCTION dup2(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup2(42);
/*
-- поля сразу будут названы так, как они в типе называются - ф1 и ф2
 f1 |     f2     
----+------------
 42 | 42 is text
(1 row)
*/
SELECT dup2(42);
/*
       dup2        
-------------------
 (42,"42 is text")
(1 row)
*/

-- типы данных можно посмотреть так:
/*
pg_db=# \dT?
        List of data types
 Schema |    Name    | Description 
--------+------------+-------------
 public | currency   | 
 public | dup_result | 
(2 rows)
*/



-- Дальше мы можем создать функции для работы с этим типом. Например:
CREATE FUNCTION multiply(factor numeric, cur currency) RETURNS currency AS $$
    SELECT ROW(factor * cur.amount, cur.code)::currency;
$$ IMMUTABLE LANGUAGE SQL;

select * from transactions;
SELECT account_id, multiply(2,debit), multiply(2,credit), date_entered FROM transactions;
/*
 account_id |   multiply   |    multiply    | date_entered 
------------+--------------+----------------+--------------
          1 | (,)          | (14000.00,RUR) | 2024-11-21
          2 | (700.00,RUR) | (,)            | 2024-11-21
          3 | (40.00,RUR)  | (,)            | 2024-11-21
(3 rows)
*/
-- то есть мы написали кастомную функцию для работы с кастомным типом данных

-- Хотелось бы, чтобы такая функция не превращала неопределенное значение в пустую запись. 
-- Для этого можно либо явно выполнить необходимую проверку, либо указать для функции свойство STRICT:
-- (чтобы возвращалась ровно 1 запись)
ALTER FUNCTION multiply(numeric, currency) STRICT;

-- Мы можем даже переопределить оператор умножения:
CREATE OPERATOR * (
    PROCEDURE = multiply,
    LEFTARG = numeric,
    RIGHTARG = currency
);
-- (если мы встречаем оператор умножения и слева у нас намерик, а справа - наш кастомный тип)

-- И использовать его в выражениях:
SELECT account_id, 1.2 * debit, 2 * credit, date_entered FROM transactions;
/*
 account_id |   ?column?    |    ?column?    | date_entered 
------------+---------------+----------------+--------------
          1 |               | (14000.00,RUR) | 2024-11-21
          2 | (420.000,RUR) |                | 2024-11-21
          3 | (24.000,RUR)  |                | 2024-11-21
(3 rows)
*/
--но если поменять аргументы местами - то работать не будет тк мы четко определили порядок (LEFTARG и RIGHTARG)
-- HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
--, поэтому нужно будет написать еще 1 функцию
SELECT account_id, debit * 2, date_entered FROM transactions;
CREATE FUNCTION multiply(cur currency, factor numeric) RETURNS currency AS $$
    SELECT ROW(factor * cur.amount, cur.code)::currency;
$$ IMMUTABLE LANGUAGE SQL;

CREATE OPERATOR * (
    PROCEDURE = multiply,
    LEFTARG = currency,
    RIGHTARG = numeric
);

SELECT account_id, debit * 2, 2 * credit, date_entered FROM transactions;

-- у создания индекса кривоватый синтаксис
drop index idx_currency;
create index idx_currency on transactions(((debit).code));


-- Составной тип как тип строки таблицы
-- При создании таблицы неявно создается одноименный тип 
-- и потом мы с этим неявным типом может работать
drop table if exists seats cascade;
CREATE TABLE seats(
    line   text,
    number integer,
    vip    boolean
);


-- Команда \dT "прячет" такие неявные типы, но при желании их можно увидеть непосредственно в таблице pg_type.
-- можно объявить как RETURNS seats:
drop function make_seat;
CREATE FUNCTION make_seat(line text, number integer, vip boolean DEFAULT false) RETURNS seats AS $$
SELECT ROW(line, number, vip)::seats;
$$ IMMUTABLE LANGUAGE SQL;

SELECT make_seat('A',32);
/*
 make_seat 
-----------
 (A,32,f)
(1 row)
*/

-- Функцию можно вызывать не только в списке выборки запроса или в условиях, как часть выражения. 
-- К функции можно обратиться и в предложении FROM, как к таблице:
SELECT * FROM make_seat('A',32);
-- при этом постгрес знает имена и типы возвращаемых данных
/*
 line | number | vip 
------+--------+-----
 A    |     32 | f
(1 row)
*/


-- вычисляемые поля
CREATE FUNCTION no(seat seats) RETURNS text AS $$
    SELECT seat.line || seat.number;
$$ IMMUTABLE LANGUAGE SQL;

SELECT no(ROW('A',32,false));
/*
 no  
-----
 A32
(1 row)
*/
INSERT INTO seats VALUES ('A',32,true), ('B',3,false), ('C',27,false);
SELECT s.line, s.number, no(s.*) FROM seats s;
/*
-- вызвали фнукцию и на вход передали все поля - no(s.*)
 line | number | no  
------+--------+-----
 A    |     32 | A32
 B    |      3 | B3
 C    |     27 | C27
(3 rows)
*/

-- !!! Синтаксисом допускается обращение к функции как к столбцу таблицы (и наоборот, к столбцу как к функции). То есть мы только что реализовали виртуальную колонку (поля no нет, но есть функция, которая принимает на вход целую строку)
SELECT s.line, number(s), s.no FROM seats s;

-- number(s) <-> s.number
-- s.no <-> no(s.*)
SELECT s.line, number(s), s.no FROM seats s; <==> SELECT s.line, s.number, no(s.*) FROM seats s;
-- запись s.no называется виртуальной колонкой


-- если совпадает имя поля и имя функции
CREATE FUNCTION line(seat seats) RETURNS text AS $$
    SELECT seat.line || seat.number;
$$ IMMUTABLE LANGUAGE SQL;

SELECT s.line, number(s) FROM seats s;
SELECT s.line, number(s), line(s) FROM seats s;
SELECT s.line, number(s), line(s.*) FROM seats s;

-- Значения составных типов можно сравнивать между собой. Это происходит поэлементно 
-- (примерно так же, так строки сравниваются посимвольно):
SELECT * FROM seats s WHERE s < make_seat('B',52);
/*
 line | number | vip 
------+--------+-----
 A    |     32 | t
 B    |      3 | f
(2 rows)
*/


-- RECORD
-- еще один вариант - объявить функцию как возвращающую псевдотип record, который обозначает составной тип "вообще", без уточнения его структуры. Минус этого подхода - мы не знаем, что там внутри (то есть мы не можем это как то обработать). Классически постгрес работает с анонимными записями довольно специфично
DROP FUNCTION make_seat(text, integer, boolean);
CREATE FUNCTION make_seat(line text, number integer, vip boolean DEFAULT false) RETURNS record AS $$
SELECT line, number, vip;
$$ IMMUTABLE LANGUAGE SQL;

SELECT make_seat('A',42);
/*
 make_seat 
-----------
 (A,42,f)
(1 row)
*/

-- Но вызвать такую функцию в предложении FROM уже не получится, поскольку возвращаемый составной тип не просто анонимный, но и количество и типы его полей заранее (на этапе разбора запроса) неизвестны (непонятно, сколько там столбцов, какого они типа и тд):
SELECT * FROM make_seat('A',42);
/*
ERROR:  a column definition list is required for functions returning "record"
LINE 1: SELECT * FROM make_seat('A',42);
*/

-- В этом случае при вызове функции структуру составного типа придется уточнить:
SELECT * FROM make_seat('A',42) AS seats(line text, number integer, vip boolean);

-- вернуть множество анонимных записей - для динамического sql
DROP FUNCTION if exists make_seat_setof(text, integer, boolean);
CREATE FUNCTION make_seat_setof(line text, number integer, vip boolean DEFAULT false) RETURNS SETOF record AS $$
begin
	return query SELECT line, number, vip, vip;
	return query select line, number, vip, vip;
end;
$$ LANGUAGE plpgSQL;
SELECT make_seat_setof('A',42);

-- одна проблема - нужно все равно указать типы при разборе анонимной записи
SELECT * FROM make_seat_setof('A',42) AS seats(line text, number integer, vip boolean, vip2 boolean);


-- Ещё один способ вернуть несколько столбцов — применить функцию TABLE:
CREATE or replace FUNCTION dup3(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup3(42);

-- Однако пример с TABLE отличается от предыдущих, так как в нём функция на самом деле возвращает не одну, а набор записей.

SELECT f1 FROM dup3(42);

-- SETOF
-- второй вариант вернуть несколько строк
-- Напишем функцию, которая вернет все места в зале заданного размера (и ближняя половина зала будет считаться vip-зоной).
CREATE FUNCTION make_seats(max_line integer, max_number integer) RETURNS SETOF seats AS $$
    SELECT chr(line+64), number, line <= max_line/2
    FROM generate_series(1,max_line) AS lines(line), generate_series(1,max_number) AS numbers(number);
    -- так как они через запятую - происходит декартово произведение!
$$ IMMUTABLE LANGUAGE SQL;

-- поименованная передача параметра - тогда они могут быть не по порядку
SELECT * FROM make_seats(max_number => 6, max_line => 12);






-- использование переменной VARIADIC массив с переменным набором аргументов
-- https://www.postgresql.org/docs/current/functions-srf.html
-- https://stackoverflow.com/questions/10674735/in-postgresql-what-is-gi-in-FROM-generate-subscripts1-1-gi
CREATE or replace FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
    -- берем и генерируем последовательность по размеру массива и берем оттуда минимальный элемент
    -- удобней чем перебрать в цикле и выбрать минимальное значение
$$ LANGUAGE SQL;

SELECT mleast(100 , 50, -1, 5, 4.4);


-- PERFORM (когда еще не было процедур)
-- Если результат запроса не нужен, можно не использовать фиктивные переменные, а заменить SELECT на PERFORM.
CREATE FUNCTION do_something() RETURNS void AS $$
BEGIN
    RAISE NOTICE 'Что-то сделалось.';
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
    PERFORM do_something();
END;
$$;



-- перегрузка
-- Напишем функцию, возвращающую большее из двух целых чисел
-- (Похожая функция есть в SQL и называется greatest, но мы сделаем ее сами)

CREATE FUNCTION maximum(a integer, b integer) RETURNS integer AS $$
SELECT CASE WHEN a > b THEN a ELSE b END;
$$ LANGUAGE SQL;


-- Проверим:
SELECT maximum(100,200);

-- Допустим, мы решили сделать аналогичную функцию для трех чисел. 
-- Благодаря перегрузке, не надо придумывать для нее какое-то новое название:

CREATE FUNCTION maximum(a integer, b integer, c integer) RETURNS integer AS $$
SELECT CASE WHEN a > b THEN maximum(a,c) ELSE maximum(b,c) END;
$$ LANGUAGE SQL;

-- Теперь у нас две функции с одним именем, но разным числом параметров:
\df maximum

-- И обе работают:
SELECT maximum(10,20), maximum(10,20,-100);

-- Пусть наша функция работает не только для целых чисел, но и для вещественных.
CREATE FUNCTION maximum(a real, b real) RETURNS real AS $$
    SELECT CASE WHEN a > b THEN a ELSE b END;
$$ LANGUAGE SQL;

-- \df maximum
SELECT maximum(10,20), maximum(3.1,3.2);



-- Полиморфные функции
-- Здесь нам поможет полиморфный тип anyelement.
-- Удалим все три наши функции и затем создадим новую:

DROP FUNCTION maximum(integer, integer);
DROP FUNCTION maximum(integer, integer, integer);
DROP FUNCTION maximum(real, real);

CREATE FUNCTION maximum(a anyelement, b anyelement) RETURNS anyelement AS $$
    SELECT CASE WHEN a > b THEN a ELSE b END;
$$ LANGUAGE SQL;

SELECT maximum(1,2);

-- попробуем сравнить строки
SELECT maximum('C','B');
-- Получится???
-- нет, тк постгрес не понимает, что это за тип - чар, варчар или текст


-- Увы, нет. В данном случае строковые литералы могут быть типа char, varchar, text - 
-- конкретный тип нам неизвестен. Но можно применить явное приведение типов:
SELECT maximum('C'::text,'B'::text);

-- Еще пример с другим типом:
SELECT maximum(now(), now() + interval '1 day');

-- Важно, чтобы типы обоих параметров совпадали, иначе будет ошибка:
SELECT maximum(1,'C');


create table test_numeric2(n numeric(38,20));



-- Процедуры
-- простая процедура
DROP TABLE IF EXISTS tbl;
CREATE TABLE tbl (i int);

CREATE or replace PROCEDURE insert_data(a integer, b integer)
LANGUAGE SQL
AS $$
INSERT INTO tbl VALUES (a);
INSERT INTO tbl VALUES (b);
$$;


-- вызовем процедуру используя CALL
CALL insert_data(1, 2);

SELECT * FROM tbl;

-- В код PL/pgSQL можно встраивать команды SQL. Наверное, наиболее часто используемый вариант - 
-- команда SELECT, возвращающая одну строку. Пример, который не получилось бы выполнить 
-- с помощью выражения с подзапросом (потому что возвращаются сразу два значения):
DROP TABLE IF EXISTS t;
CREATE TABLE t(id integer, code text);
INSERT INTO t VALUES (1, 'Один'), (3, 'Три');

-- анонимная процедура
DO $$
DECLARE
    r record;
BEGIN
    SELECT id, code INTO r FROM t WHERE id = 1;
    RAISE NOTICE '%', r;
END;
$$;
-- NOTICE:  (1,Один)
-- если б мы указали стрикт - у нас был бы эксепшн что больше 1 строчки
```

Еще полезные штуки из лекции:
- Мы можем отловить любую ошибку в постгресе, а затем ее обработать! У нас есть список ошибок, которые мы можем поймать (там их больше 200)
- через RAISE NOTICE можно удобно дебажить код - повысить уровень логирования

## ДЗ

Практика №1

1. Создать таблицу с продажами.
2. Реализовать функцию выбор трети года (1-4 мес - первая треть, 5-8 - вторая и т.д.)  
    a. Через case  
    b. * (бонуса в виде зачета дз не будет) используя математическую операцию (лучше 2 варианта)  
    c. предусмотреть NULL на входе
3. Вызвать эту функцию в SELECT из таблицы с продажами, убедиться, что всё отработало

Вызвать селект из таблички sales и выбрать от даты продажи, какая треть года. (если месяц 1-4 - вывести 1 и тд). 2б - есть порядка 5 вариантов реализации