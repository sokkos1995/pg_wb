# Управление соединениями и пулконнекторы

## Маршрут вебинара

- Принципы подключения в PostgreSQL - pg_hba, fork backend process, work_mem, проблематика
- Назначение и виды пуллконнекторов
- Pgbouncer - принципы работы, настройка и возможный troubleshooting
- Проблематика idle и idle in transaction - исследование и рекомендации
- Управление пользователями - архитектура, принципы и подходы, caveats

## Проблематика

Кроме это выделяется память для каждой сессии
- принадлежит КАЖДОМУ backend процессу
- work_mem 4 MB эта память используется на этапе выполнения запроса
- maintenance_work_mem 64MB используется служебными операциями типа VACUUM и REINDEX
- temp_buffers 8 MB используется на этапе выполнения для хранения временных таблиц

Принадлежит каждому backend процессу:
- work_mem 4 MB - эта память используется на этапе выполнения запроса для сортировок строк, например ORDER BY и DISTINCT - выделяться может неоднократно!!! https://www.postgresql.org/docs/current/runtime-config-resource.html
- maintenance_work_mem 64MB используется служебными операциями типа VACUUM и REINDEX
- выделяется только при использовании команд обслуживания в сессии
- temp_buffers 8 MB используется на этапе выполнения для хранения временных таблиц - При превышении work_mem или temp_buffers - дальше идем в temp tablespace. 

## work_mem

Используется для сортировок, построения hash таблиц. Это позволяет выполнять данные операции в памяти, что гораздо быстрее обращения к диску. В рамках одного запроса данный параметр может быть использован несколько раз. Если ваш запрос содержит 5 операций сортировки, то память, которая может использоваться для его выполнения уже может сожрать как минимум work_mem * 5. Т.к. скорее-всего на сервере вы не одни и сессий много, то каждая из них может использовать этот параметр по нескольку раз, поэтому не рекомендуется делать его слишком большим. Можно выставить небольшое значение для глобального параметра в конфиге и потом, в случае сложных запросов, менять этот параметр
локально (для текущей сессии). Обратите внимание, что при превышении этого параметра будет использовано временное пространство, расположенное на диске - запросы будут выполняться медленнее и при большом запросе с декартовым произведением могут привести к
опустошению пустого места на диске и завершаться с ошибкой, также могут способствовать приходу ООМ киллера в зависимости от конфигурации ОС.

На самом деле всё очень сложно:)

Измеряем расходы на память у Postgres процессов Например не чистый форк, а механизм copy-on-write - копия только изменененных страниц. В версии Postgres 14 появилось новое представление pg_backend_memory_contexts которое показывает подробную утилизацию памяти текущим процессом с точки зрения самого Postgres.
```sql
SELECT  FROM pg_backend_memory_contexts;
```

Памяти у инстанса 32 Gb (периодически приходил OOM killer)
max_connections = 1000
shared_buffers = 40GB
work_mem = 64MB
maintenance_work_mem = 1024MB
https://www.kernel.org/doc/gorman/html/understand/understand016.html

Общая формула:
ОЗУ  2Gb + Shared buffers + max_connections * (work_mem + temp_buffers) +
maintance_parallel_workers * maintance_work_mem.
С учетом того, что work_mem может выделяться несколько раз.
Правда не весь объем сразу резервируется, но есть шанс OOM killer.

## Варианты доступа к кластеру

На предыдущем занятии мы установили Постгрес на ВМ. После установки Постгрес запускается с такими параметрами: 
Одна инсталяция инстанса Постгреса называется кластером
При этом при установке создается Linux пользователь postgres
Он предназначен для запуска кластера Постгреса и является владельцем всех файлов,
относящихся к Постгресу - исполняемых файлов, файлов данных и логов
По умолчанию к этим файлам кроме него могут получить доступ только
суперпользователи Линукс - root и группа пользователей, имеющая право на запуск
утилиты sudo - позволяющей повысить свои личные права до прав суперпользователя

Доступ к Постгресу после запуска возможен только через psql и Unix socket
Это означает, что пароль от единственного пользователя СУБД НЕ будет запрашиваться
при входе в Постгрес, вместо этого Постгрес спросил у ОС - авторизован ли такой
пользователь в ОС.
В нашем случае суперпользователь БД также имеет имя postgres и если мы в Линукс
перейдем от нашего пользователя aeugene к пользователю postgres, повысив свои права
до суперпользователя Линукс и дав команду переключиться на пользователя postgres, то
при запуске утилиты psql Постгрес спросит у Линукса авторизован ли пользователь
postgres и пустит внутрь СУБД без пароля. Иначе доступ мы не получим.

Для проверки подключения необходимо выполнить 3 шага:
Набрать в консоли команду для перехода под пользователя postgres
sudo su postgres
2. Зайти в утилиту управления СУБД
psql
3. Посмотреть параметры подключения
\conninfo
Второй вариант - повысить свои права до суперюзера и подключиться:
sudo -u postgres psql

Кроме подключения по Unix Socket стандартным подключением к СУБД является
подключение по сети (протокол TCP/IP)
Для того, чтобы зайти по сети мы должны отредактировать два конфигурационных
файла:
hba_file.conf - настройки встроенного в Постгрес файрвола
postgresql.conf - настройки Постгреса, в том числе подключений извне
Расположение этих файлов зависит от типа и варианта ОС. Посмотреть, где они
расположены можно из утилиты psql:
show hba_file;
show config_file;
P.S. чтобы вставить в консоль скопированные команды в VirtualBox нужно нажать
Ctrl+Shift+V

В Ubuntu данные файлы расположены:
/etc/postgresql/16/main/pg_hba.conf
/etc/postgresql/16/main/postgresql.conf
Посмотрим на настройки файрвола, для этого:
выйдем из psql
\q или exit
обратите разницу на строку подключения при нахождении в Линукс и в psql
postgres@postgres Linux VS
postgres=# (psql - пользователь СУБД postgres, не Линукса)
Команды Линукса в psql выполнятся не будут и наоборот

Используем утилиту просмотра файлов cat под текущим пользователем Линукс postgres
cat /etc/postgresql/16/main/pg_hba.conf
Важно! Открывать только сетевое подключение в доверенной локальной сети!
НЕ рекомендуется открывать доступ в интернет!
P.S. если комбинация Alt+Tab для переключения окон не выпускает нас из ВМ в VirtualBox -
необходимо сначала нажать кнопку правый Ctrl для освобождения удерживаемого фокуса

с 14 версии используется система шифрования паролей SCRAMSHA256,
в более ранних версиях - система MD5
! они не совместимы, при обновлении кластера с 13 на 14+ версию нужно это иметь
ввиду.
! не стоит использовать систему PASSWORD - Пароль передается в открытом виде!

Чтобы задать пароль необходимо выполнить:
Зайти в консоль
psql
2. Установить пароль для текущего пользователя
а) команда psql
\password
или
 б) SQL команда
 ALTER USER postgres PASSWORD '123';

Теперь мы можем зайти по сети на localhost 127.0.0.1.
Для этого необходимо выполнить 3 шага:
выйти из psql
\q
2. подключиться указав хост для подключения
psql -h localhost
3. посмотреть статус подключения
\conninfo
Видим, что теперь мы вместо Unix Socket подключились по сети с локалхоста
P.S. psql мы запускаем из линукса из под пользователя postgres, а НЕ student. Если
закрыли консоль, переключиться на пользователя postgres можно выполнив sudo su
postgres

## Подключение извне

Для подключения извне ВМ, нам необходимо сделать несколько больше шагов:
включаем listener в postgresql.conf (обычно 2 сети - внутренняя и внешняя - интернет.
Подключение через интернет категорически не рекомендуется)
listen_addresses = '*' # IP адреса, на которых принимает подключения Постгрес,
например localhost, 10.*.*.*;
# второй вариант
# alter system set listen_addresses = ‘*ʼ;
включаем вход по паролю в pg_hba.conf и меняем маску подсети
host all all 0.0.0.0/0 scram-sha-256
в 13 и меньше версии scram-sha-256 → md5
добавляем порт во внешний файрвол, используемый у вас в организации

4. задаем пароль юзеру postgres
ALTER USER postgres PASSWORD '123';
5. Перегружаем сервер - обратите внимание, что при установке PostgreSQL запущен от
имени root и рестарт от пользователя postgres мы сделать не можем (только stop и потом
start). Правильно потом переконфигурировать пользователя на postgres при старте ВМ.
pg_ctlcluster 16 main restart
Вуаля
psql -h 104.197.151.20 U postgres
Мы оказались внутри нашего кластера и можем посмотреть параметры подключения
выполнив
\conninfo

## Подключение из других версий

Так как у PostgreSQL открытый протокол обмена между кластерами и версиями, то
никаких проблем при совместимости, начиная с версии 9.6, не наблюдается.
Естественно, если вы используете psql 16 версии и подключаетесь к 10, то функционал
будет доступен только 10 версии)

## Текущая конфигурация

Несмотря на встроенный файрвол - Постгрес не средство защиты от DDoS и
других атак:
- желательно работать только в доверенной зоне
- меняем стандартный порт
- аккуратнее поднимаем докер контейнеры с портом наружу -p 54325432 - лучше
докер сеть и по ней доступ к бэкендам (касается и k8s и port-forward как
вариант)
- сложные пароли - ибо никто ботов не отменял

- Безопасность наше все!
- Только проверенные источники (официальные образы, bitnami, etc)
- Тестируем контейнеры на безопасность
- Открывать доступ извне для БД - плохая идея (помним про порты)
- Мультистейдж сборка - в 1 окружении собрали jar, потом в минимальном окружении
запустили типа apline
- группируем команды, возможно есть смысл к 1 слою все схлопнуть
- Конфиги в 1 каталоге, который и монтируем внутрь контейнера
- Указываем версию контейнера - latest плохая практика из-за несовместимости
файлов БД разных версий
- docker → containerd && CRIO из-за отсутствия поддержки c-groups 2.0

Вспоминаем, что каждый коннект это клон процесса + выделение памяти.
Поэтому используем пулер (pooler). Легковесные постоянные коннекты от
бэкендов и постоянные соединения в БД.
- Pgpool II
- pg_bouncer + haproxy
- Odyssey
Ну или использовать готовые кластера

- используется встроенный механизм репликации
- есть пул соединений
- балансировщик нагрузки
- высокая доступность (наблюдатель с виртуальным IP, автоматическое
переключение мастера)
Как раз излишек функционала и есть основная проблема производительности
Pgpool2
https://severalnines.com/database-blog/guide-pgpool-postgresql-part-one

PgBouncer - пул соединений:
- легковесный - 2 Кб на соединение
- можно выбрать тип соединения: на сессию, транзакцию или каждую
операцию
- онлайн-реконфигурация без сброса подключений
PgBouncer спроектирован однопоточным. Он сделан максимально простым и в
этой простоте масштабируемость не присутствует как класс. Вот в CPU мы
видим 97 % загрузки. База при этом не так, чтобы занята, но Bouncer не успевает
передавать байтики туда и сюда.
Сравнение
https://scalegrid.io/blog/postgresql-connection-pooling-part-4-pgbouncer-vs-pgpoo

Видим поднятый каскадом PgBouncer, где у нас есть внутренний Bouncer,
который по-прежнему уперт в одно ядро.
Вы можете в каскаде обойтись без внутреннего PgBouncer, но тогда у вас будет
connection pool внутри каждого процесса PgBouncer. И снова приходим к той же
проблеме, что у нас много коннектов.
Внешний слой PgBouncer обычно используется для приема волны TLS
соединений. TLSсоединения – это операция, которая требует участие центрального
процессора значительно больше, чем типичное перекладывание байтов из сокета в
сокет. Т. е. для центрального процессора потоки данных, измеренные в байтах в
секунду, они не заметны. Но необходимость выполнять криптографию при TLS
handshake существенна. 

Если у вас приложение по какой-то причине бросило соединение с базой данных,
то PgBouncer продолжит выполнять тот запрос, который выполнялся. На эту
проблему обращали внимание много раз. Авторы Odyssey написали pull request. Он
принят не был. Его рассматривают до сих пор. И это еще одна проблема, что
PgBouncer не очень хорошо саппортился.
Пришлось изобретать свой велосипед.

Odyssey
https://github.com/yandex/odyssey

разбор архитектуры - https://habr.com/ru/articles/498250/

Новичок нашего пула:
pg agroal is a high-performance protocol-native connection pool
- High performance
- Connection pool
- Limit connections for users and databases
- Prefill support
- Remove idle connections
- Perform connection validation
etc..
https://github.com/agroal/pgagroal

Суперновичок нашего пула:
Supavisor - https://github.com/supabase/supavisor
- Apache 2.0
- Highly available
- Connection buffering
- Cloud-native
- Multi-tenant
- Scalable
- Load balancing
1 млн коннектов:
https://supabase.com/blog/supavisor-1-million

У каждого ЯП свои пулеры.
Java - Hikari - периодические проблемы
etc..
Общие проблемы:
- свой зоопарк
- держат коннект с конкретным инстансом - нет учета особенностей
переключения между бэкендами
- сложность равномерно распределить нагрузку

В зависимости от задачи и профиля нагрузки тестируем на дев стенде, помня об
ограничениях, плюсах и минусах.
На что стоит обратить внимание:
- количество коннектов
- нагрузка на сеть/проц
- минимизация обмена данными по сети
- делать меньше запросов
- читать меньше данных
- обновлять меньше данных (несколько update insert в одну транзакцию)
- уменьшать обработку на лету
- проанализировать передачу данных
➢ сколько данных было просканировано - сколько отослано
➢ сколько было отослано - сколько использовано приложением

- бэкап снимаем с secondary
- возможно есть смысл в каскадной репликации при проблемах с
производительностью сети
- не забываем про OLAP - делаем специальную реплику, возможно например
подключить clickhouse
- геораспределение нагрузки
- не забываем про LTстенды (Стенд для нагрузочного тестирования: от DEV до
PROD )

Использование TLS/SSL Secure Socket Layer) для защищенного соединения с PostgreSQL внутри
закрытой периметрии (например, внутри безопасной сети или сети виртуальных машин) имеет свои
плюсы и минусы:
Плюсы использования SSL
- Шифрование данных: SSL обеспечивает шифрование данных между клиентом и сервером, что
делает перехват и утечку информации более сложными для злоумышленников, даже если они
имеют доступ к внутренней сети.
- Доверие и безопасность: Использование SSL помогает подтвердить подлинность сервера перед
клиентом и создает доверительный канал для обмена данными. Это защищает от атак "человек
посередине" (Man-in-the-Middle) и поддерживает целостность данных.
- Соответствие стандартам и нормам: В зависимости от вашей отрасли и законодательства, вам
может потребоваться шифрование данных, даже если они передаются внутри закрытой сети.
Использование SSL позволяет соответствовать стандартам безопасности данных.
- Защита от внутренних угроз: Внутренние угрозы, такие как злоумышленники внутри сети, могут
попытаться перехватить данные или осуществить атаки на базу данных. SSL помогает уменьшить
риски таких атак.

Минусы использования SSL внутри закрытой периметрии:
- Дополнительная нагрузка на производительность: Шифрование и расшифровка данных может
вызвать некоторую нагрузку на производительность сервера PostgreSQL. В закрытой сети эта
нагрузка может быть излишней.
- Сложность настройки: Настройка SSL требует наличия корректных сертификатов, и это может
быть сложно в случае внутренних сетей. Неправильная настройка может привести к проблемам
соединения.
- Увеличение сложности обслуживания: Внедрение SSL увеличивает сложность конфигурации и
обслуживания базы данных. Это может потребовать дополнительных шагов при развертывании и
обновлении.
- Затраты на ресурсы: Создание и управление сертификатами требует времени и ресурсов.
Возможно, вам потребуется наличие собственной инфраструктуры управления сертификатами.
В целом, использование SSL внутри закрытой периметрии имеет смысл, если вы стремитесь к
обеспечению дополнительного уровня безопасности, защиты данных и соответствия стандартам.
Однако следует тщательно взвесить плюсы и минусы в соответствии с требованиями вашей
организации и сетевой инфраструктурой.

Обеспечение безопасности базы данных PostgreSQL
● Безопасность на сетевом уровне
● Безопасность на транспортном уровне
● Безопасность на уровне базы данных

Неплохо бы еще добавить HAPROXY для балансинга нагрузки
https://www.percona.com/blog/2018/10/02/scaling-postgresql-using-connection-poolers
-and-load-balancers-for-an-enterprise-grade-environment/
Еще варианты балансеров:
- используем или встроенный GLB в облако или варианты:
- NGINX https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/
4 варианта со своими + и -:

## Модели использования прав доступа

Три основных модели (а уж сколько комбинаций):
1. RBAC внутри PG (можно прикрутить LDAP, AD, IPA и тд):
- можем дотюнить доступ вплоть до колонки
- несмотря на тяжесть настройки в целом при интеграции с LDAP есть и
плюсы, но и тяжесть сопоставления ролей
- излишне ветвистая структура прав доступа - легко что-нибудь упустить из
вида
- сложность изменения структура БД, необходимо помнить про групповые
права на LDAP
- потеря производительности - проверка доступа каждый раз при обращении к
тому или иному объекту

2. Одна или несколько групповых учеток и RBAC на бэке:
- очевидная легкость настройки и простота
- функционал юзера ограничиваем на бэке
- дополнительный слой логики при проектировании приложения
- недоступные функции просто у юзера не будут отображаться
- не забываем заблокировать учетку уволенного сотрудника
- предпочтительный вариант

3. Набор хранимок с нужными правами (security definer) - напрямую к таблицам никто доступа не имеет:
- можем менять структуру независимо от приложения - главное имя хранимки сохранить
- легко вводить новый функционал или убирать старый
- дополнительный слой абстракции, платим производительностью
- можем получить сайд эффекты после изменений цепочки вызовов, особенно если этим занимаются разные команды  
https://www.cybertec-postgresql.com/en/abusing-security-definer-functions/

Тут все упирается в ресурсы людей для поддержки железа и ПО и финансовых возможностей компании. Когда все на одном сервере и на одной БД - это круто, но если что-то падает - это глобальный простой. Опять же, а если надо откатить данные только одной схемы … Глобально зависит от заложенной архитектуры, RTO, RPO, SLA и тд (с) один мой друг ДБА

## Checklist

- учитываем количество коннектов
- если больше 500 - выбираем пулер
- обязательно тестирование на вашем железе, объеме и профиле нагрузки
- учитываем рекомендации по сетевому обмену
- совместно с СБ выбираем модель SSL и терминации трафика
- выбираем модель балансинга в соответствии с вашим железом и бизнес задачами
- совместно с СБ выбираем модель RBAC
- учитываем риски утечки чувствительных данных